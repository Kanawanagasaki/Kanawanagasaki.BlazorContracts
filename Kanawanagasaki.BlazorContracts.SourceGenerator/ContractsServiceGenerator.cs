namespace Kanawanagasaki.BlazorContracts.SourceGenerator;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Text;

[Generator]
public class ContractsServiceGenerator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat SYMB_DISPLAY_FORMAT_GENERICS = new
    (
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var handlersDeclarations = context.SyntaxProvider.CreateSyntaxProvider
        (
            static (node, _) => node is ClassDeclarationSyntax classDecl && classDecl.BaseList is not null,
            static (ctx, _) => ctx.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)ctx.Node)
        );

        var compilations = context.CompilationProvider.Combine(handlersDeclarations.Collect());

        context.RegisterSourceOutput(compilations, Execute);
    }


    private void Execute(SourceProductionContext context, (Compilation, ImmutableArray<INamedTypeSymbol?>) tuple)
    {
        var (compilation, handlersSymbols) = tuple;

        var injectedServices = new Dictionary<string, string>();
        var noResponseContracts = new List<(string contractType, string handlerType, HashSet<string> servicesNames)>();
        var withResponseContracts = new List<(string contractType, string handlerType, HashSet<string> servicesNames, string responseType)>();

        foreach (var handler in handlersSymbols)
        {
            if (handler is null)
                continue;

            var handlerInterface = handler.AllInterfaces.FirstOrDefault(
                x => x.ContainingNamespace.ToString() + "." + x.Name == "Kanawanagasaki.BlazorContracts.IContractHandler");
            if (handlerInterface is null)
                continue;
            if (handlerInterface.TypeArguments.Length == 0)
                continue;

            var contractType = handlerInterface.TypeArguments[0];
            if (contractType is not INamedTypeSymbol contract)
                continue;

            var servicesTypes = new HashSet<string>();
            var constructor = handler.Constructors.FirstOrDefault(x => x.DeclaredAccessibility is Accessibility.Public);
            if (constructor is not null)
            {
                foreach (var param in constructor.Parameters)
                {
                    var fullname = param.Type.ToDisplayString(SYMB_DISPLAY_FORMAT_GENERICS);

                    if (!injectedServices.ContainsKey(fullname))
                        injectedServices[fullname] = $"_injected_service_" + (injectedServices.Count + 1);

                    servicesTypes.Add(injectedServices[fullname]);
                }
            }

            if (handlerInterface.TypeArguments.Length < 2)
            {
                noResponseContracts.Add(
                (
                    $"{contract.ContainingNamespace}.{contract.Name}",
                    $"{handler.ContainingNamespace}.{handler.Name}",
                    servicesTypes
                ));
            }
            else
            {
                var responseType = handlerInterface.TypeArguments[1];
                if (responseType is INamedTypeSymbol response)
                {
                    withResponseContracts.Add(
                    (
                        $"{contract.ContainingNamespace}.{contract.Name}",
                        $"{handler.ContainingNamespace}.{handler.Name}",
                        servicesTypes,
                        $"{response.ContainingNamespace}.{response.Name}"
                    ));
                }
                else if (responseType is IArrayTypeSymbol arr && arr.ElementType is INamedTypeSymbol response2)
                {
                    withResponseContracts.Add(
                    (
                        $"{contract.ContainingNamespace}.{contract.Name}",
                        $"{handler.ContainingNamespace}.{handler.Name}",
                        servicesTypes,
                        $"{response2.ContainingNamespace}.{response2.Name}[]"
                    ));
                }
            }
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("namespace Kanawanagasaki.BlazorContracts;");
        sb.AppendLine("public class ContractsService : Kanawanagasaki.BlazorContracts.IContractsService{");

        foreach (var kv in injectedServices)
            sb.AppendLine($"private readonly {kv.Key} {kv.Value};");

        sb.AppendLine("public ContractsService(");
        sb.AppendLine(string.Join(",\n", injectedServices.Select(kv => $"{kv.Key} {kv.Value}")));
        sb.AppendLine(")\n{");
        foreach (var kv in injectedServices)
            sb.AppendLine($"this.{kv.Value} = {kv.Value};");
        sb.AppendLine("}");

        sb.AppendLine("public System.Threading.Tasks.Task<Kanawanagasaki.BlazorContracts.ContractResult> ProcessAsync(Kanawanagasaki.BlazorContracts.IContract req){");
        sb.AppendLine("try {");
        sb.AppendLine("switch (req) {");
        for (int i = 0; i < noResponseContracts.Count; i++)
        {
            var meta = noResponseContracts[i];
            sb.AppendLine($"case {meta.contractType} _contract_{i + 1}:");
            sb.AppendLine($"var _handler_{i + 1} = new {meta.handlerType}({string.Join(",", meta.servicesNames)});");
            sb.AppendLine($"return _handler_{i + 1}.HandleAsync(_contract_{i + 1}, default);");
        }
        sb.AppendLine("default: return System.Threading.Tasks.Task.FromResult(new Kanawanagasaki.BlazorContracts.ContractResult(405));");
        sb.AppendLine("}");
        sb.AppendLine("}");
        sb.AppendLine("catch (System.Exception e) {");
        sb.AppendLine("return System.Threading.Tasks.Task.FromResult(new Kanawanagasaki.BlazorContracts.ContractResult(500, e.Message));");
        sb.AppendLine("}");
        sb.AppendLine("}");

        sb.AppendLine("public async System.Threading.Tasks.Task<Kanawanagasaki.BlazorContracts.ContractResult<TResponse>> ProcessAsync<TResponse>(Kanawanagasaki.BlazorContracts.IContract<TResponse> req) where TResponse : class{");
        sb.AppendLine("try {");
        sb.AppendLine("switch(req){");
        for (int i = 0; i < withResponseContracts.Count; i++)
        {
            var meta = withResponseContracts[i];
            sb.AppendLine($"case {meta.contractType} _contract_{i + 1}:");
            sb.AppendLine($"var _handler_{i + 1} = new {meta.handlerType}({string.Join(",", meta.servicesNames)});");
            sb.AppendLine($"var _result_{i + 1} = await _handler_{i + 1}.HandleAsync(_contract_{i + 1}, default);");
            sb.AppendLine($"return (Kanawanagasaki.BlazorContracts.ContractResult<TResponse>)(object)_result_{i + 1};");
        }
        sb.AppendLine("default: return new Kanawanagasaki.BlazorContracts.ContractResult<TResponse>(405);");
        sb.AppendLine("}");
        sb.AppendLine("}");
        sb.AppendLine("catch (System.Exception e) {");
        sb.AppendLine("return new Kanawanagasaki.BlazorContracts.ContractResult<TResponse>(500, e.Message);");
        sb.AppendLine("}");
        sb.AppendLine("}");

        sb.AppendLine("}");

        context.AddSource("ContractsService.g.cs", sb.ToString());
    }

    private static T? FindParentOfType<T>(SyntaxNode node) where T : SyntaxNode
    {
        var parent = node.Parent;
        while (parent is not null && parent is not T)
            parent = parent.Parent;
        return parent as T;
    }
}
